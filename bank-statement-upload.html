<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bank Statement Upload</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    #status { margin-top: 1rem; color: blue; }
    table { border-collapse: collapse; margin-top: 1rem; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background: #f4f4f4; }
  </style>
</head>
<body>
  <h2>Upload Bank Statement</h2>
  <input type="file" id="fileInput" accept=".csv,.xlsx,.xls"/>
  <div id="status"></div>
  <div id="preview"></div>

  <script>
    document.getElementById("fileInput").addEventListener("change", handleFile, false);

    function handleFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById("status").textContent = "Processing...";
      const ext = file.name.split(".").pop().toLowerCase();

      if (ext === "csv") {
        parseCSV(file).then(processTransactions).catch(showError);
      } else if (ext === "xlsx" || ext === "xls") {
        parseExcel(file).then(processTransactions).catch(showError);
      } else {
        showError("Unsupported file type");
      }
    }

    // Parse CSV using PapaParse
    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            resolve(results.data);
          },
          error: reject
        });
      });
    }

    // Parse Excel using SheetJS
    function parseExcel(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const sheet = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheet];

            // Get raw rows
            const raw = XLSX.utils.sheet_to_json(worksheet, {
              header: 1,
              defval: ""
            });

            console.log("Raw Excel rows:", raw);

            if (raw.length === 0) {
              reject("No data found in Excel file");
              return;
            }

            // Detect header row (look for 'Date' or 'Txn Date')
            let headerRowIndex = raw.findIndex(r =>
              r.some(cell =>
                String(cell).toLowerCase().includes("date") ||
                String(cell).toLowerCase().includes("description") ||
                String(cell).toLowerCase().includes("amount")
              )
            );
            if (headerRowIndex === -1) headerRowIndex = 0;

            const headers = raw[headerRowIndex].map(h => String(h).trim());
            const rows = raw.slice(headerRowIndex + 1).map(row => {
              let obj = {};
              headers.forEach((header, i) => {
                obj[header] = row[i];
              });
              return obj;
            });

            // Remove empty rows
            const cleaned = rows.filter(r => Object.values(r).some(val => val !== "" && val != null));
            resolve(cleaned);

          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject("Error reading file");
        reader.readAsArrayBuffer(file);
      });
    }

    // Process transactions
    function processTransactions(transactions) {
      console.log("Parsed transactions:", transactions);

      if (!transactions || transactions.length === 0) {
        showError("No transactions found.");
        return;
      }

      // Normalize keys
      const normalized = transactions.map(t => {
        const date = t.Date || t["Txn Date"] || t["Transaction Date"] || "";
        const description = t.Description || t["Narration"] || t["Details"] || "";
        const amount = t.Amount || t["Debit"] || t["Credit"] || t["Transaction Amount"] || "";
        const type = t.Type || (t["Debit"] ? "Expense" : "Income");

        return {
          Date: date,
          Description: description,
          Amount: amount,
          Type: type
        };
      });

      showPreview(normalized);
      document.getElementById("status").textContent = "File processed successfully!";
    }

    // Show preview table
    function showPreview(data) {
      const preview = document.getElementById("preview");
      preview.innerHTML = "";

      if (data.length === 0) return;

      let html = "<table><tr><th>Date</th><th>Description</th><th>Amount</th><th>Type</th></tr>";
      data.forEach(t => {
        html += `<tr>
          <td>${t.Date}</td>
          <td>${t.Description}</td>
          <td>${t.Amount}</td>
          <td>${t.Type}</td>
        </tr>`;
      });
      html += "</table>";

      preview.innerHTML = html;
    }

    function showError(msg) {
      document.getElementById("status").textContent = "Error: " + msg;
      console.error(msg);
    }
  </script>
</body>
</html>
